 package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;
import ast.E;
import ast.AS;
import ast.Ins;
import java.util.List;
import java.util.ArrayList;
import ast.FuncionOIden;
import ast.IfConElse;
import ast.P;
import ast.DecConValorIni;
import ast.Tipos;
import ast.AsigODec;
import ast.CorchetesYPuntosIzq;


scan with {: return getScanner().next_token(); :};
action code {:
   private AS as = new AS();
:};

parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal    TRUE, FALSE, CREAVECTOR, 
 			SIZE, WHILE, FOR, SWITCH, CASE, BREAK, IF, CALL, ELSE, PROC, FUN, RETURN, 
 			STRUCT, TYPEDEF, ENUM, SUMA, RESTA,
 			MUL, DIVREAL, DIVENT, MODULO, AND, OR, NOT, MENOR, 
 			MAYOR, MENORIGUAL, MAYORIGUAL, IGUALIGUAL, DISTINTO, PUNTO, 
			LLAVESAP, LLAVESCIERRE, BARRA, PAP, PCIERRE, IGUAL, COMA, 
 			PUNTOYCOMA, CORCHETEAP, CORCHETECIERRE, DOSPUNTOS, DEFAULT;
terminal    String IDEN, ENT, REAL, CARACTER; 
terminal    Tipos INT, BOOL, CHAR, FLOAT, VECTOR;

 
non terminal  InsFun, Param, ParamElige, InsProc, InsCall, LIden, LIdenElige, InsStruct, InsEnum, LEnum, LEnumElige,
			  InsTypeDef, DecConNuevosTipos, LDec,  
			  InsSwitch, ListaCase, TiposSwitch;
non terminal  E Exp, Exp0, Exp1, Exp2, Exp3, Exp4, Exp5, Exp6, Exp7, Exp8, CreaVector;
non terminal  FuncionOIden ListaArg, ListaArg1, FuncionOIden;
non terminal  IfConElse ConElse;
non terminal  P P;
non terminal  Ins InsCond, Inst, InsBucle, InsIdenOInsDec, InsDec, InsIden;
non terminal  DecConValorIni AsigDec;
non terminal  AsigODec InsIdenElige, InsAsig;
non terminal  List<CorchetesYPuntosIzq> CorchetesPuntosIzq;
non terminal  Tipos TipoSinIden, Tipo;



	
P ::= Inst:ins P:prog 
	{: prog.anadeIns(ins);
	   RESULT = prog; :};
P ::= 
	{: RESULT = as.programa(); :};


Inst ::= InsCond:valorInsCond 
{: RESULT = valorInsCond; :};

Inst ::= InsBucle:valorInsBucle
{:RESULT = valorInsBucle; :};

Inst ::= InsDec:valorInsDec
{: RESULT = valorInsDec; :};

Inst ::=  InsSwitch | InsFun | InsProc | InsStruct | InsEnum | InsTypeDef | InsCall;

Inst ::= InsIden:valorInsIden
{: RESULT = valorInsIden; :};



InsIden ::= IDEN:lexDeIden InsIdenElige:valorAsigODec
	{: if (valorAsigODec.isEsDec()){
			if (valorAsigODec.isConValorIni()){
				RESULT = as.insDec(as.tipoUsuario(lexDeIden), valorAsigODec.getIdenSiDec(), true, valorAsigODec.getValor());
			}
			else{
				RESULT = as.insDec(as.tipoUsuario(lexDeIden), valorAsigODec.getIdenSiDec(), false, null);
			}
		}
		else{
			RESULT = as.insAsig(as.iden(lexDeIden), valorAsigODec.getLista(), valorAsigODec.getValor());
		}
	:};


InsIdenElige ::= IDEN:lexDeIden AsigDec:valorAsig 
	{: RESULT = as.asigODec(true, valorAsig.isConValorIni(), valorAsig.getValorIni(), as.iden(lexDeIden), null); :};

InsIdenElige ::= CorchetesPuntosIzq:lista InsAsig:asig
	{: asig.setLista(lista);
		RESULT = asig; :};

CorchetesPuntosIzq ::= CORCHETEAP Exp0:valorExp CORCHETECIERRE CorchetesPuntosIzq:valorCorchPunto 
	{: valorCorchPunto.add(0, as.corchetesIzq(valorExp));
		RESULT = valorCorchPunto; :};
CorchetesPuntosIzq ::= PUNTO IDEN:lexDeIden CorchetesPuntosIzq:valorCorchPunto 
	{: valorCorchPunto.add(0, as.puntosIzq(as.iden(lexDeIden)));
		RESULT = valorCorchPunto; :}; 
CorchetesPuntosIzq ::= 
	{: RESULT = new ArrayList<CorchetesYPuntosIzq>(); :};

InsDec ::= TipoSinIden:tipo IDEN:lexDeIden AsigDec:valorIni
{: if(valorIni.isConValorIni()){
		RESULT = as.insDec(tipo, as.iden(lexDeIden), true, valorIni.getValorIni());
	}
	else {
		RESULT = as.insDec(tipo, as.iden(lexDeIden), false, null);
	}
:} ;


AsigDec ::= PUNTOYCOMA
	{:RESULT = as.decConValorIni(false, null); :}; 
	
AsigDec ::= IGUAL Exp:valorExp PUNTOYCOMA
	{:RESULT = as.decConValorIni (true, valorExp); :};

Tipo ::= INT | BOOL | CHAR | FLOAT | VECTOR MENOR Tipo MAYOR | IDEN;

TipoSinIden ::= INT
	{:RESULT = as.tipoInt(); :}; 
TipoSinIden ::= BOOL
	{:RESULT = as.tipoBool(); :}; 
TipoSinIden ::= CHAR
	{:RESULT = as.tipoChar(); :};
TipoSinIden ::= FLOAT 
	{:RESULT = as.tipoFloat(); :};
TipoSinIden ::= VECTOR MENOR Tipo:tipo MAYOR
	{:RESULT = as.tipoVector(tipo); :};


InsCond ::= IF Exp:cond LLAVESAP P:insIf LLAVESCIERRE ConElse:insElse
	{:  if(insElse.isVieneConElse()){
	   		RESULT = as.insIfConElse(cond, insIf, insElse.getInstElse());
	   	}
	   	else{
	   		RESULT = as.insIfSinElse(cond, insIf);
	   	}
	 :};
	
	

ConElse ::= ELSE LLAVESAP P:insElse LLAVESCIERRE
	{: RESULT = as.ifConElse(true, insElse); :};
	
ConElse ::= 
	{:RESULT = as.ifConElse(false, new P()); :};
	

InsBucle ::= WHILE Exp:cond LLAVESAP P:ins LLAVESCIERRE 
{: RESULT = as.insWhile(cond, ins); :};
InsBucle ::= FOR PAP InsIdenOInsDec:insDec Exp0:cond PUNTOYCOMA Exp0:paso PCIERRE LLAVESAP P:inst LLAVESCIERRE
{: RESULT = as.insFor(insDec, cond, paso, inst); :};

InsIdenOInsDec ::= InsIden:ins 
	{: RESULT = ins; :};
InsIdenOInsDec ::= InsDec:ins
	{: RESULT = ins; :};
	
	
InsSwitch ::= SWITCH PAP IDEN CorchetesPuntosIzq PCIERRE LLAVESAP ListaCase LLAVESCIERRE;
ListaCase ::= CASE TiposSwitch DOSPUNTOS P BREAK PUNTOYCOMA ListaCase | DEFAULT DOSPUNTOS P;
TiposSwitch ::= ENT | REAL | TRUE | FALSE | CARACTER | IDEN;

InsAsig ::= IGUAL Exp:valorExp PUNTOYCOMA
	{: RESULT = as.asigODec(false, true, valorExp, null, null); :};

InsFun ::= FUN Tipo IDEN PAP Param PCIERRE LLAVESAP P RETURN Exp PUNTOYCOMA LLAVESCIERRE;
Param ::= Tipo IDEN ParamElige | ;
ParamElige ::= COMA Tipo IDEN ParamElige | ;

InsProc ::= PROC IDEN PAP Param PCIERRE LLAVESAP P LLAVESCIERRE;

InsCall ::= CALL IDEN PAP LIden PCIERRE PUNTOYCOMA;
LIden ::= IDEN LIdenElige | ;
LIdenElige ::= COMA IDEN LIdenElige | ;

InsStruct ::= STRUCT IDEN LLAVESAP LDec LLAVESCIERRE;
LDec ::= DecConNuevosTipos LDec | ;

InsEnum ::= ENUM IDEN IGUAL LLAVESAP LEnum LLAVESCIERRE PUNTOYCOMA;
LEnum ::= IDEN LEnumElige | ;
LEnumElige ::= BARRA IDEN LEnumElige | ;

InsTypeDef ::= TYPEDEF Tipo IDEN PUNTOYCOMA;


Exp ::= Exp0: valorExp
	{: RESULT= valorExp; :};
Exp ::= CreaVector: valorExp
	{: RESULT = valorExp; :};
Exp0 ::= Exp1:valorExp1 OR Exp0:valorExp2
	{:RESULT = as.or(valorExp1, valorExp2); :};
Exp0 ::= Exp1:valorExp
	{: RESULT = valorExp; :};
Exp1 ::= Exp2:valorExp1 AND Exp1:valorExp2
	{:RESULT = as.and(valorExp1, valorExp2); :};
Exp1 ::= Exp2:valorExp
	{: RESULT = valorExp; :};
Exp2 ::= Exp3:valorExp1 IGUALIGUAL Exp3:valorExp2 
	{:RESULT = as.igualIgual(valorExp1, valorExp2); :};
Exp2 ::= Exp3:valorExp1 MAYOR Exp3:valorExp2
	{:RESULT = as.mayor(valorExp1, valorExp2); :}; 
Exp2 ::= Exp3:valorExp1 MENOR Exp3:valorExp2 
	{:RESULT = as.menor(valorExp1, valorExp2); :}; 
Exp2::= Exp3:valorExp1 MAYORIGUAL Exp3:valorExp2
	{:RESULT = as.mayorIgual(valorExp1, valorExp2); :}; 
Exp2::= Exp3:valorExp1 MENORIGUAL Exp3:valorExp2
	{:RESULT = as.menorIgual(valorExp1, valorExp2); :}; 
Exp2 ::= Exp3:valorExp1 DISTINTO Exp3:valorExp2
	{:RESULT = as.distinto(valorExp1, valorExp2); :}; 
Exp2 ::= Exp3: valorExp
	{: RESULT = valorExp; :};
	
	
Exp3 ::= Exp3:valorExp1 SUMA Exp4:valorExp2
	{:RESULT = as.suma(valorExp1, valorExp2); :}; 
Exp3 ::= Exp3:valorExp1 RESTA Exp4:valorExp2
	{:RESULT = as.resta(valorExp1, valorExp2); :};  
Exp3 ::= Exp4: valorExp
	{: RESULT = valorExp; :};
	

Exp4 ::= Exp4:valorExp1 MUL Exp5:valorExp2
	{:RESULT = as.mul(valorExp1, valorExp2); :};
Exp4 ::= Exp4:valorExp1 DIVENT Exp5:valorExp2 
	{:RESULT = as.divEnt(valorExp1, valorExp2); :};
Exp4 ::= Exp4:valorExp1 DIVREAL Exp5:valorExp2
	{:RESULT = as.divReal(valorExp1, valorExp2); :}; 
Exp4 ::= Exp4:valorExp1 MODULO Exp5:valorExp2
	{:RESULT = as.modulo(valorExp1, valorExp2); :}; 
Exp4 ::= Exp5: valorExp
	{: RESULT = valorExp; :};


Exp5 ::= NOT Exp5:valorExp
	{: RESULT = as.not(valorExp); :}; 
Exp5 ::= Exp6: valorExp
	{: RESULT = valorExp; :};
	

Exp6 ::= Exp6:valorExp1 CORCHETEAP Exp0:valorExp2 CORCHETECIERRE
	{:RESULT = as.corchetes(valorExp1, valorExp2); :};
Exp6 ::= Exp6:valorExp PUNTO IDEN:lexDeIden
	{:RESULT = as.punto(valorExp, as.iden(lexDeIden)); :};
Exp6 ::= Exp6:valorExp PUNTO SIZE
	{: RESULT = as.size(valorExp); :}; 
Exp6 ::= Exp7: valorExp
	{: RESULT = valorExp; :};
	

Exp7 ::= RESTA Exp8:valorExp
	{: RESULT = as.restaUnaria(valorExp); :}; 
Exp7 ::= SUMA Exp8:valorExp
	{: RESULT = as.sumaUnaria(valorExp); :};  
Exp7 ::= Exp8: valorExp
	{: RESULT = valorExp; :};
	

	
Exp8 ::= ENT: lexDeEnt
	{: RESULT = as.ent(lexDeEnt); :}; 
Exp8 ::= REAL: lexDeReal
	{: RESULT = as.real(lexDeReal); :};  
Exp8 ::= TRUE
	{: RESULT = as.verdadero(); :};  
Exp8 ::= FALSE
	{: RESULT = as.falso(); :}; 
Exp8 ::= CARACTER: lexDeCaracter
	{: RESULT = as.caracter(lexDeCaracter); :};  
Exp8 ::= IDEN:lexDeIden FuncionOIden:valorExp
	{:  if (valorExp.isEsIden()){
		 	RESULT = as.iden(lexDeIden);
		 }
		 else{
		 	RESULT = as.llamadaFun(as.iden(lexDeIden), valorExp.getArgumentos());
		 }
	:};  
Exp8 ::= PAP Exp0: valorExp PCIERRE
	{: RESULT = valorExp; :};
	
FuncionOIden ::= PAP ListaArg:valorExp PCIERRE
	{: RESULT = valorExp; :};
FuncionOIden ::= 
	{: RESULT = as.funcionOIden(true, null); :};

ListaArg ::= ListaArg1:valorExp 
	{: RESULT = valorExp; :};

ListaArg ::= 
	{: RESULT = as.funcionOIden(false, new ArrayList<E>()); :};
ListaArg1 ::= Exp0:elem COMA ListaArg1:valorExp
	{: valorExp.anadeElem(elem);
	   RESULT = valorExp; :};
ListaArg1 ::= Exp0:elem
	{: List<E> args = new ArrayList<E>();
	   args.add(elem);
	   RESULT = as.funcionOIden(false, args); :};


CreaVector ::= CREAVECTOR PAP CreaVector:valorExp1 COMA Exp0:valorExp2 PCIERRE
	{: RESULT = as.vector(valorExp1, valorExp2); :};
CreaVector ::= CREAVECTOR PAP Exp0:valorExp1 COMA Exp0:valorExp2 PCIERRE
	{: RESULT = as.vector(valorExp1, valorExp2); :};
