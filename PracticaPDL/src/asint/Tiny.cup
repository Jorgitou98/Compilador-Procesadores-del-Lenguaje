package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;
import ast.E;
import ast.AS;
import ast.Ins;
import java.util.List;
import java.util.ArrayList;
import ast.P;
import ast.Tipos;
import ast.Case;
import ast.TipoParam;
import ast.Param;


scan with {: return getScanner().next_token(); :};
action code {:
   private AS as = new AS();
   public static int numErrores = 0;
:};

parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal    TRUE, FALSE, CREAVECTOR, 
 			SIZE, WHILE, FOR, SWITCH, CASE, BREAK, IF, CALL, ELSE, PROC, FUN, RETURN, 
 			STRUCT, TYPEDEF, ENUM, SUMA, RESTA,
 			MUL, DIVREAL, DIVENT, MODULO, AND, OR, NOT, MENOR, 
 			MAYOR, MENORIGUAL, MAYORIGUAL, IGUALIGUAL, DISTINTO, PUNTO, 
			LLAVESAP, LLAVESCIERRE, BARRA, PAP, PCIERRE, IGUAL, COMA, 
 			PUNTOYCOMA, CORCHETEAP, CORCHETECIERRE, DOSPUNTOS, DEFAULT,
 			AMPERSAND, NEW, NULL;
terminal    String IDEN, ENT, REAL, CARACTER; 
terminal    Tipos INT, BOOL, CHAR, FLOAT, VECTOR;

non terminal  P P;
non terminal  Ins InsCond, Inst, InsBucle, InsDec, InsAsig, InsCall, InsSwitch, InsFun, InsProc, InsStruct, InsEnum, InsTypeDef, 
				InsDecConValorIni, InsNew;
non terminal  E Exp, Exp0, Exp1, Exp2, Exp3, Exp4, Exp5, Exp6, Exp7, Exp8, CreaVector, TiposSwitch; 
non terminal  List<E> ListaArg, ListaArg1, LEnum, LEnumElige;
non terminal  List<Case> ListaCase;
non terminal  List<Param> Parametros, ParamElige;
non terminal  List<Ins> LDec;
non terminal  Tipos Tipo;

	
P ::= Inst:ins P:prog 
	{: prog.anadeIns(ins);
	   RESULT = prog; :};
P ::= 
	{: RESULT = as.programa(); :};



Inst ::= InsCond:valorInsCond 
{: RESULT = valorInsCond; :};

Inst ::= InsBucle:valorInsBucle
{: RESULT = valorInsBucle; :};

Inst ::= InsDec:valorInsDec
{: RESULT = valorInsDec; :};

Inst ::= InsAsig:valorInsAsig
{: RESULT = valorInsAsig; :};

Inst ::=  InsCall:valorInsCall
{: RESULT = valorInsCall; :};

Inst ::= InsSwitch:valorInsSwitch
{: RESULT = valorInsSwitch; :};

Inst ::= InsFun:valorInsFun
{: RESULT = valorInsFun; :};

Inst ::= InsProc:valorInsProc
{: RESULT = valorInsProc; :};

Inst ::= InsStruct:valorInsStruct
{: RESULT = valorInsStruct; :};

Inst ::= InsEnum:valorInsEnum
{: RESULT = valorInsEnum; :};

Inst ::= InsTypeDef:valorInsTypeDef
{: RESULT = valorInsTypeDef; :};

Inst ::= InsNew:valorInsNew
{: RESULT = valorInsNew; :};

Inst ::= error PUNTOYCOMA
{: numErrores += 1; RESULT = null; :};


InsNew ::= Exp0:var IGUAL NEW Tipo:tipo PAP Exp:valor PCIERRE PUNTOYCOMA
{: RESULT = as.insNew(tipo, var, valor); :};


InsCond ::= IF Exp0:cond LLAVESAP P:insIf LLAVESCIERRE
	 {: RESULT = as.insIfSinElse(cond, insIf); :};

InsCond ::= IF Exp0:cond LLAVESAP P:insIf LLAVESCIERRE ELSE LLAVESAP P:insElse LLAVESCIERRE
	{: RESULT = as.insIfConElse(cond, insIf, insElse); :};





InsBucle ::= WHILE Exp0:cond LLAVESAP P:ins LLAVESCIERRE 
{: RESULT = as.insWhile(cond, ins); :};

InsBucle ::= FOR PAP InsDecConValorIni:insDec Exp0:cond PUNTOYCOMA Exp0:paso PCIERRE LLAVESAP P:inst LLAVESCIERRE
{: RESULT = as.insFor(insDec, cond, paso, inst); :};

InsBucle ::= FOR PAP InsAsig:insAsig Exp0:cond PUNTOYCOMA Exp0:paso PCIERRE LLAVESAP P:inst LLAVESCIERRE
{: RESULT = as.insFor(insAsig, cond, paso, inst); :};





InsDec ::= InsDecConValorIni: ins
{:RESULT = ins; :};

InsDec ::= Tipo: tipo IDEN: lexDeIden PUNTOYCOMA
{:RESULT = as.insDec(tipo, as.iden(lexDeIden, true), false, null); :};

InsDecConValorIni ::= Tipo: tipo IDEN: lexDeIden IGUAL Exp:valorExp PUNTOYCOMA
{:RESULT = as.insDec(tipo, as.iden(lexDeIden, true), true, valorExp); :};

Tipo ::= INT
	{:RESULT = as.tipoInt(); :}; 	
Tipo ::= BOOL
	{:RESULT = as.tipoBool(); :}; 	
Tipo ::= CHAR
	{:RESULT = as.tipoChar(); :};	
Tipo ::= FLOAT 
	{:RESULT = as.tipoFloat(); :};
Tipo ::= VECTOR MENOR Tipo:tipo MAYOR
	{:RESULT = as.tipoVector(tipo); :};
Tipo ::= IDEN:lexIden
	{:RESULT = as.tipoUsuario(lexIden); :};
Tipo ::= MENOR Tipo: tipo MAYOR MUL
	{:RESULT = as.tipoPuntero(tipo); :};






InsAsig ::= Exp0:var IGUAL Exp0:valorExp PUNTOYCOMA
{: RESULT = as.insAsig(var, valorExp); :};






InsCall ::= CALL IDEN:lexDeIden PAP ListaArg:lista PCIERRE PUNTOYCOMA
 {: RESULT = as.insCall(as.iden(lexDeIden, true), lista); :};
 
 ListaArg ::= ListaArg1:valorExp 
	{: RESULT = valorExp; :};

ListaArg ::= 
	{: RESULT = new ArrayList<E>(); :};
ListaArg1 ::= Exp0:elem COMA ListaArg1:lista
	{: lista.add(0, elem);
	   RESULT = lista; :};
ListaArg1 ::= Exp0:elem
	{: List<E> args = new ArrayList<E>();
	   args.add(elem);
	   RESULT = args; :};
 
 
 
 
 
 
InsSwitch ::= SWITCH PAP Exp0:var PCIERRE LLAVESAP ListaCase:lista LLAVESCIERRE
	{: RESULT = as.insSwitch(var, lista); :};

ListaCase ::= CASE TiposSwitch:var DOSPUNTOS P:instr BREAK PUNTOYCOMA ListaCase:lista
	 {:lista.add(0, as.createCase(var, instr));
       RESULT = lista; :};
	 
ListaCase ::= DEFAULT DOSPUNTOS P:instr
	 {: List<Case> lista = new ArrayList<Case>();
	 	lista.add(0, as.createCase(as.iden("default", true), instr));
	 	RESULT = lista;
	 :};
	    
TiposSwitch ::= ENT:lexDeEnt
	{: RESULT = as.ent(lexDeEnt, false); :}; 
TiposSwitch ::= REAL:lexDeReal
	{: RESULT = as.real(lexDeReal, false); :};  
TiposSwitch ::= TRUE
	{: RESULT = as.verdadero(false); :};     
TiposSwitch ::= FALSE
	{: RESULT = as.falso(false); :};    
TiposSwitch ::= CARACTER:lexDeCaracter
	{: RESULT = as.caracter(lexDeCaracter, false); :};
TiposSwitch ::= IDEN:lexDeIden
	{: RESULT = as.iden(lexDeIden, true); :};





 
InsFun ::= FUN Tipo:tipoReturn IDEN:lexDeIden PAP Parametros:params PCIERRE LLAVESAP P:instr RETURN Exp:valorReturn PUNTOYCOMA LLAVESCIERRE
	{: RESULT = as.insFun(tipoReturn, as.iden(lexDeIden, true), params, instr, valorReturn); :};
 
Parametros ::= Tipo:tipoParam AMPERSAND IDEN:lexDeIden ParamElige:lista
	{: lista.add(0, as.param(tipoParam, TipoParam.REFERENCIA, as.iden(lexDeIden, true)));
		RESULT = lista; :};
	 
Parametros ::= Tipo:tipoParam IDEN:lexDeIden ParamElige:lista
	{: lista.add(0, as.param(tipoParam, TipoParam.VALOR, as.iden(lexDeIden, true)));
		RESULT = lista; :};

Parametros ::= 
	{: RESULT = new ArrayList<Param>(); :};
	
ParamElige ::= COMA Tipo:tipoParam AMPERSAND IDEN:lexDeIden ParamElige:lista
	{: lista.add(0, as.param(tipoParam, TipoParam.REFERENCIA, as.iden(lexDeIden, true)));
		RESULT = lista; :};
		 
ParamElige ::= COMA Tipo:tipoParam IDEN:lexDeIden ParamElige:lista  
	{: lista.add(0, as.param(tipoParam, TipoParam.VALOR, as.iden(lexDeIden, true)));
		RESULT = lista; :};
		
ParamElige ::= 
	{: RESULT = new ArrayList<Param>(); :};
	
	
	
	
	

InsProc ::= PROC IDEN:lexDeIden PAP Parametros:params PCIERRE LLAVESAP P:instr LLAVESCIERRE
    {: RESULT = as.insProc(as.iden(lexDeIden, true), params, instr); :};






InsStruct ::= STRUCT IDEN:lexDeIden LLAVESAP LDec:listaDec LLAVESCIERRE
	{: RESULT = as.insStruct(as.iden(lexDeIden, true), listaDec); :};
LDec ::= InsDec: ins LDec :listaDec
	{: listaDec.add(0,ins);
	   RESULT = listaDec; :};
LDec::= 
	{:RESULT = new ArrayList<Ins>(); :};






InsEnum ::= ENUM IDEN: lexDeIden IGUAL LLAVESAP LEnum: listaCtes LLAVESCIERRE PUNTOYCOMA
	{: RESULT = as.insEnum(as.iden(lexDeIden, true), listaCtes); :};

	
LEnum ::= IDEN: lexDeIden LEnumElige: listaCtes
	{: listaCtes.add(0, as.iden(lexDeIden, true));
	   RESULT = listaCtes; :};
LEnum::=  
	{: RESULT = new ArrayList<E>(); :};
	
LEnumElige ::= BARRA IDEN: lexDeIden LEnumElige: listaCtes
	{: listaCtes.add(0, as.iden(lexDeIden, true));
	   RESULT = listaCtes; :};
	   
LEnumElige::= 
	{: RESULT = new ArrayList<E>(); :};




	
InsTypeDef ::= TYPEDEF Tipo:tipo IDEN:lexDeIden PUNTOYCOMA
	{: RESULT = as.insTypeDef(tipo, as.iden(lexDeIden, true)); :};







Exp ::= Exp0: valorExp
	{: RESULT= valorExp; :};
Exp ::= CreaVector: valorExp
	{: RESULT = valorExp; :};
	
	
Exp0 ::= Exp1:valorExp1 OR Exp0:valorExp2
	{:RESULT = as.or(valorExp1, valorExp2, false); :};
Exp0 ::= Exp1:valorExp
	{: RESULT = valorExp; :};
	
	
Exp1 ::= Exp2:valorExp1 AND Exp1:valorExp2
	{:RESULT = as.and(valorExp1, valorExp2, false); :};
Exp1 ::= Exp2:valorExp
	{: RESULT = valorExp; :};
	
	
Exp2 ::= Exp3:valorExp1 IGUALIGUAL Exp3:valorExp2 
	{:RESULT = as.igualIgual(valorExp1, valorExp2, false); :};
Exp2 ::= Exp3:valorExp1 MAYOR Exp3:valorExp2
	{:RESULT = as.mayor(valorExp1, valorExp2, false); :}; 
Exp2 ::= Exp3:valorExp1 MENOR Exp3:valorExp2 
	{:RESULT = as.menor(valorExp1, valorExp2, false); :}; 
Exp2::= Exp3:valorExp1 MAYORIGUAL Exp3:valorExp2
	{:RESULT = as.mayorIgual(valorExp1, valorExp2, false); :}; 
Exp2::= Exp3:valorExp1 MENORIGUAL Exp3:valorExp2
	{:RESULT = as.menorIgual(valorExp1, valorExp2, false); :}; 
Exp2 ::= Exp3:valorExp1 DISTINTO Exp3:valorExp2
	{:RESULT = as.distinto(valorExp1, valorExp2, false); :}; 
Exp2 ::= Exp3: valorExp
	{: RESULT = valorExp; :};
		
		
Exp3 ::= Exp3:valorExp1 SUMA Exp4:valorExp2
	{:RESULT = as.suma(valorExp1, valorExp2, false); :}; 
Exp3 ::= Exp3:valorExp1 RESTA Exp4:valorExp2
	{:RESULT = as.resta(valorExp1, valorExp2, false); :};  
Exp3 ::= Exp4: valorExp
	{: RESULT = valorExp; :};
	
	
Exp4 ::= Exp4:valorExp1 MUL Exp5:valorExp2
	{:RESULT = as.mul(valorExp1, valorExp2, false); :};
Exp4 ::= Exp4:valorExp1 DIVENT Exp5:valorExp2 
	{:RESULT = as.divEnt(valorExp1, valorExp2, false); :};
Exp4 ::= Exp4:valorExp1 DIVREAL Exp5:valorExp2
	{:RESULT = as.divReal(valorExp1, valorExp2, false); :}; 
Exp4 ::= Exp4:valorExp1 MODULO Exp5:valorExp2
	{:RESULT = as.modulo(valorExp1, valorExp2, false); :}; 
Exp4 ::= Exp5: valorExp
	{: RESULT = valorExp; :};


Exp5 ::= NOT Exp5:valorExp
	{: RESULT = as.not(valorExp, false); :}; 
Exp5 ::= Exp6: valorExp
	{: RESULT = valorExp; :};
	

Exp6 ::= Exp6:valorExp1 CORCHETEAP Exp0:valorExp2 CORCHETECIERRE
	{:RESULT = as.corchetes(valorExp1, valorExp2, true); :};
Exp6 ::= Exp6:valorExp PUNTO IDEN:lexDeIden
	{:RESULT = as.punto(valorExp, as.iden(lexDeIden, true), true); :};
Exp6 ::= Exp6:valorExp PUNTO SIZE
	{: RESULT = as.size(valorExp, false); :}; 
Exp6 ::= Exp7: valorExp
	{: RESULT = valorExp; :};
	

Exp7 ::= RESTA Exp8:valorExp
	{: RESULT = as.restaUnaria(valorExp, false); :}; 
Exp7 ::= SUMA Exp8:valorExp
	{: RESULT = as.sumaUnaria(valorExp, false); :}; 
Exp7 ::= MUL Exp8:valorExp
	{: RESULT = as.accesoPuntero(valorExp, true); :};  
Exp7 ::= Exp8: valorExp
	{: RESULT = valorExp; :};
	

	
Exp8 ::= ENT: lexDeEnt
	{: RESULT = as.ent(lexDeEnt, false); :}; 
Exp8 ::= REAL: lexDeReal
	{: RESULT = as.real(lexDeReal, false); :};  
Exp8 ::= TRUE
	{: RESULT = as.verdadero(false); :};  
Exp8 ::= FALSE
	{: RESULT = as.falso(false); :};
Exp8 ::= NULL
	{: RESULT = as.nulo(false); :}; 
Exp8 ::= CARACTER: lexDeCaracter
	{: RESULT = as.caracter(lexDeCaracter, false); :};  
Exp8 ::= IDEN:lexDeIden PAP ListaArg:lista PCIERRE
	{: RESULT = as.llamadaFun(as.iden(lexDeIden, true), lista, false); :};
Exp8 ::= IDEN PAP error PCIERRE
	{: numErrores += 1; RESULT = null; :};
Exp8 ::= IDEN:lexDeIden
	{: RESULT = as.iden(lexDeIden, true); :};
Exp8 ::= PAP Exp0: valorExp PCIERRE
	{: RESULT = valorExp; :};
Exp8 ::= PAP error PCIERRE
{: numErrores += 1; RESULT = null; :};


CreaVector ::= CREAVECTOR PAP CreaVector:valorExp1 COMA Exp0:valorExp2 PCIERRE
	{: RESULT = as.vector(valorExp1, valorExp2, false); :};
CreaVector ::= CREAVECTOR PAP Exp0:valorExp1 COMA Exp0:valorExp2 PCIERRE
	{: RESULT = as.vector(valorExp1, valorExp2, false); :};
