 package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;
import ast.E;
import ast.AS;
import ast.Ins;
import java.util.ArrayList;


scan with {: return getScanner().next_token(); :};
action code {:
   private AS as = new AS();
   private String funcionOIdenh;
   private ArrayList<E> argumentosh;
:};

parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal    INT, BOOL, CHAR, TRUE, FALSE, FLOAT, VECTOR, CREAVECTOR, 
 			SIZE, WHILE, FOR, SWITCH, CASE, BREAK, IF, CALL, ELSE, PROC, FUN, RETURN, 
 			STRUCT, TYPEDEF, ENUM, SUMA, RESTA,
 			MUL, DIVREAL, DIVENT, MODULO, AND, OR, NOT, MENOR, 
 			MAYOR, MENORIGUAL, MAYORIGUAL, IGUALIGUAL, DISTINTO, PUNTO, 
			LLAVESAP, LLAVESCIERRE, BARRA, PAP, PCIERRE, IGUAL, COMA, 
 			PUNTOYCOMA, CORCHETEAP, CORCHETECIERRE, DOSPUNTOS, DEFAULT;
terminal    String IDEN, ENT, REAL, CARACTER; 

non terminal  Q, InsIden, InsIdenElige, InsDec, AsigDec, Tipo, TipoSinIden, InsBucle, InsAsig,
              InsFun, Param, ParamElige, InsProc, InsCall, LIden, LIdenElige, InsStruct, InsEnum, LEnum, LEnumElige,
			  InsTypeDef, DecConNuevosTipos, LDec,
			  CorchetesPuntosIzq, InsSwitch, ListaCase, TiposSwitch, InsIdenOInsDec;
non terminal  E Exp, Exp0, Exp1, Exp2, Exp3, Exp4, Exp5, Exp6, Exp7, Exp8, CreaVector, ListaArg, ListaArg1, FuncionOIden;
non terminal  Ins Inst, InsCond, ConElse;
non terminal  P P, P1;


Q ::= InsCond:valorIns
	{: RESULT = valorIns; :};
	
P ::= {: ArrayList<Ins> listaIns = new ArrayList<Ins>(); :} Inst:valorIns {: listaIns.add(valorIns); :} P1:valorProg
	{: RESULT = valorProg; :};
P::= {: RESULT = as.programa(new ArrayList<Ins>()); :};
P1 ::= Inst:valorInst {: listaIns.add(valorIns); :} P1:valorProg
 {:RESULT = valorProg;:};

P1::= {:RESULT = as.programa(listaIns); :};

Inst ::= InsCond:valorIns | InsDec | InsBucle | InsSwitch | InsIden | InsFun | InsProc | InsStruct | InsEnum | InsTypeDef | InsCall
{: RESULT = valorIns; :};


InsIden ::= IDEN InsIdenElige;
InsIdenElige ::= IDEN AsigDec | CorchetesPuntosIzq InsAsig;

CorchetesPuntosIzq ::= CORCHETEAP Exp0 CORCHETECIERRE CorchetesPuntosIzq |  PUNTO IDEN CorchetesPuntosIzq | ;

InsDec ::= TipoSinIden IDEN AsigDec;
AsigDec ::= PUNTOYCOMA | IGUAL Exp PUNTOYCOMA;

Tipo ::= INT | BOOL | CHAR | FLOAT | VECTOR MENOR Tipo MAYOR | IDEN;
TipoSinIden ::= INT | BOOL | CHAR | FLOAT | VECTOR MENOR Tipo MAYOR;

InsCond ::= IF Exp:valorExp {: E expCondh = valorExp; :} LLAVESAP P:insIf {:P insIfCondh=insIf:} LLAVESCIERRE ConElse:valorIns
	{:RESULT = valorIns :};

ConElse ::= ELSE LLAVESAP P:insElse LLAVESCIERRE
	{: RESULT = as.ifConElse(expCondh, insIfCondh,insElse); :}; 
ConElse ::= 
	{:RESULT = as.ifSinElse(expCondh, insIfCondh); :};

InsBucle ::= WHILE Exp LLAVESAP P LLAVESCIERRE | FOR PAP InsIdenOInsDec Exp0 PUNTOYCOMA Exp0 PCIERRE LLAVESAP P LLAVESCIERRE;
InsIdenOInsDec ::= InsIden | InsDec;

InsSwitch ::= SWITCH PAP IDEN CorchetesPuntosIzq PCIERRE LLAVESAP ListaCase LLAVESCIERRE;
ListaCase ::= CASE TiposSwitch DOSPUNTOS P BREAK PUNTOYCOMA ListaCase | DEFAULT DOSPUNTOS P;
TiposSwitch ::= ENT | REAL | TRUE | FALSE | CARACTER | IDEN;

InsAsig ::= IGUAL Exp PUNTOYCOMA;

InsFun ::= FUN Tipo IDEN PAP Param PCIERRE LLAVESAP P RETURN Exp PUNTOYCOMA LLAVESCIERRE;
Param ::= Tipo IDEN ParamElige | ;
ParamElige ::= COMA Tipo IDEN ParamElige | ;

InsProc ::= PROC IDEN PAP Param PCIERRE LLAVESAP P LLAVESCIERRE;

InsCall ::= CALL IDEN PAP LIden PCIERRE PUNTOYCOMA;
LIden ::= IDEN LIdenElige | ;
LIdenElige ::= COMA IDEN LIdenElige | ;

InsStruct ::= STRUCT IDEN LLAVESAP LDec LLAVESCIERRE;
LDec ::= DecConNuevosTipos LDec | ;

InsEnum ::= ENUM IDEN IGUAL LLAVESAP LEnum LLAVESCIERRE PUNTOYCOMA;
LEnum ::= IDEN LEnumElige | ;
LEnumElige ::= BARRA IDEN LEnumElige | ;

InsTypeDef ::= TYPEDEF Tipo IDEN PUNTOYCOMA;


Exp ::= Exp0: valorExp
	{: RESULT= valorExp; :};
Exp ::= CreaVector: valorExp
	{: RESULT = valorExp; :};
Exp0 ::= Exp1:valorExp1 OR Exp0:valorExp2
	{:RESULT = as.or(valorExp1, valorExp2); :};
Exp0 ::= Exp1:valorExp
	{: RESULT = valorExp; :};
Exp1 ::= Exp2:valorExp1 AND Exp1:valorExp2
	{:RESULT = as.and(valorExp1, valorExp2); :};
Exp1 ::= Exp2:valorExp
	{: RESULT = valorExp; :};
Exp2 ::= Exp3:valorExp1 IGUALIGUAL Exp3:valorExp2 
	{:RESULT = as.igualIgual(valorExp1, valorExp2); :};
Exp2 ::= Exp3:valorExp1 MAYOR Exp3:valorExp2
	{:RESULT = as.mayor(valorExp1, valorExp2); :}; 
Exp2 ::= Exp3:valorExp1 MENOR Exp3:valorExp2 
	{:RESULT = as.menor(valorExp1, valorExp2); :}; 
Exp2::= Exp3:valorExp1 MAYORIGUAL Exp3:valorExp2
	{:RESULT = as.mayorIgual(valorExp1, valorExp2); :}; 
Exp2::= Exp3:valorExp1 MENORIGUAL Exp3:valorExp2
	{:RESULT = as.menorIgual(valorExp1, valorExp2); :}; 
Exp2 ::= Exp3:valorExp1 DISTINTO Exp3:valorExp2
	{:RESULT = as.distinto(valorExp1, valorExp2); :}; 
Exp2 ::= Exp3: valorExp
	{: RESULT = valorExp; :};
	
	
Exp3 ::= Exp3:valorExp1 SUMA Exp4:valorExp2
	{:RESULT = as.suma(valorExp1, valorExp2); :}; 
Exp3 ::= Exp3:valorExp1 RESTA Exp4:valorExp2
	{:RESULT = as.resta(valorExp1, valorExp2); :};  
Exp3 ::= Exp4: valorExp
	{: RESULT = valorExp; :};
	

Exp4 ::= Exp4:valorExp1 MUL Exp5:valorExp2
	{:RESULT = as.mul(valorExp1, valorExp2); :};
Exp4 ::= Exp4:valorExp1 DIVENT Exp5:valorExp2 
	{:RESULT = as.divEnt(valorExp1, valorExp2); :};
Exp4 ::= Exp4:valorExp1 DIVREAL Exp5:valorExp2
	{:RESULT = as.divReal(valorExp1, valorExp2); :}; 
Exp4 ::= Exp4:valorExp1 MODULO Exp5:valorExp2
	{:RESULT = as.modulo(valorExp1, valorExp2); :}; 
Exp4 ::= Exp5: valorExp
	{: RESULT = valorExp; :};


Exp5 ::= NOT Exp5:valorExp
	{: RESULT = as.not(valorExp); :}; 
Exp5 ::= Exp6: valorExp
	{: RESULT = valorExp; :};
	

Exp6 ::= Exp6:valorExp1 CORCHETEAP Exp0:valorExp2 CORCHETECIERRE
	{:RESULT = as.corchetes(valorExp1, valorExp2); :};
Exp6 ::= Exp6:valorExp PUNTO IDEN:lexDeIden
	{:RESULT = as.punto(valorExp, as.iden(lexDeIden)); :};
Exp6 ::= Exp6:valorExp PUNTO SIZE
	{: RESULT = as.size(valorExp); :}; 
Exp6 ::= Exp7: valorExp
	{: RESULT = valorExp; :};
	

Exp7 ::= RESTA Exp8:valorExp
	{: RESULT = as.restaUnaria(valorExp); :}; 
Exp7 ::= SUMA Exp8:valorExp
	{: RESULT = as.sumaUnaria(valorExp); :};  
Exp7 ::= Exp8: valorExp
	{: RESULT = valorExp; :};
	

	
Exp8 ::= ENT: lexDeEnt
	{: RESULT = as.ent(lexDeEnt); :}; 
Exp8 ::= REAL: lexDeReal
	{: RESULT = as.real(lexDeReal); :};  
Exp8 ::= TRUE
	{: RESULT = as.verdadero(); :};  
Exp8 ::= FALSE
	{: RESULT = as.falso(); :}; 
Exp8 ::= CARACTER: lexDeCaracter
	{: RESULT = as.caracter(lexDeCaracter); :};  
Exp8 ::= IDEN:lexDeIden {: funcionOIdenh = lexDeIden; :} FuncionOIden:valorExp
	{:  RESULT = valorExp; :};  
Exp8 ::= PAP Exp0: valorExp PCIERRE
	{: RESULT = valorExp; :};
	
FuncionOIden ::= PAP {:argumentosh = new ArrayList<E>(); :} ListaArg:valorExp PCIERRE
	{: RESULT = valorExp; :};
FuncionOIden ::= 
	{: RESULT = as.iden(funcionOIdenh); :};

ListaArg ::= ListaArg1:valorExp 
	{: RESULT = valorExp; :};

ListaArg ::= 
	{: RESULT = as.llamadaFun(as.iden(funcionOIdenh), argumentosh); :};
ListaArg1 ::= Exp0:elem {:argumentosh.add(elem); :} COMA ListaArg1:valorExp
	{: RESULT = valorExp; :};
ListaArg1 ::= Exp0:elem
	{: argumentosh.add(elem);
   	RESULT = as.llamadaFun(as.iden(funcionOIdenh), argumentosh); :};


CreaVector ::= CREAVECTOR PAP CreaVector:valorExp1 COMA Exp0:valorExp2 PCIERRE
	{: RESULT = as.vector(valorExp1, valorExp2); :};
CreaVector ::= CREAVECTOR PAP Exp0:valorExp1 COMA Exp0:valorExp2 PCIERRE
	{: RESULT = as.vector(valorExp1, valorExp2); :};
